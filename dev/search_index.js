var documenterSearchIndex = {"docs":
[{"location":"social_preview/#Social-preview","page":"Social preview","title":"Social preview","text":"","category":"section"},{"location":"social_preview/","page":"Social preview","title":"Social preview","text":"Here is the code to draw the social preview image:","category":"page"},{"location":"social_preview/","page":"Social preview","title":"Social preview","text":"using OrdinaryDiffEq, Plots\nusing LinearAlgebra: norm\nusing LagrangianDescriptors\n\nfunction f!(du, u, p, t)\n    x, y = u\n    A, ω = p\n    du[1] = y\n    du[2] = x - x^3 + A * sin(ω * t)\nend\n\nu0 = [0.5, 2.2]\ntspan = (0.0, 13.0)\nA = 5.0; ω = 2π; p = (A, ω);\nprob = ODEProblem(f!, u0, tspan, p)\n\nM(du, u, p, t) = norm(du)\nuu0 = [[x, y] for y in range(-1.5, -0.5, length=301), x in range(-0.4, 1.6, length=601)]\nlagprob = LagrangianDescriptorProblem(prob, M, uu0)\n\nlagsol = solve(lagprob, Tsit5())","category":"page"},{"location":"social_preview/","page":"Social preview","title":"Social preview","text":"plot(lagsol, :forward, size=(1280, 640), colorbar=false, axes=false, ticks=false)\n\nannotate!([(0.6,-1.1,text(\"LagrangianDescriptors.jl\",68, :white, :center, \"Times\")),(0.6,-1.25, text(\"Painting the phase portrait of random and deterministic systems\", 26, :white, :center, \"Times\"))])","category":"page"},{"location":"social_preview/","page":"Social preview","title":"Social preview","text":"savefig(\"img/LagrangianDescriptors_socialpreview.png\")","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Problems","page":"API","title":"Problems","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LagrangianDescriptors.augmentprob","category":"page"},{"location":"api/#LagrangianDescriptors.augmentprob","page":"API","title":"LagrangianDescriptors.augmentprob","text":"augmentprob(prob::ODEProblem, M; direction::Symbol=:both)\n\nCreate an augmented ODEProblem by aggregating the forward and backward Lagrangian descriptors to the given ODEProblem.\n\nMore precisely, with given f = prob.f, u0 = prob.u0, and tspan = prob.tspan, an augmented ODEProblem is created that solves the forward and backward ODE and the forward and backward Lagrangian descriptors simultaneously.\n\nThe (global) Lagrangian descriptors are based on the provided local descriptor M=M(du, u, p, t). The (forward/backward) Lagrangian descriptor is the time-integration of the local descriptor along the (forward/backward) trajectory.\n\nIf direction=:forward or direction=:backward are given, then only the forward or backard problem is constructed in the augmented system. The default is direction=:both, where both directions are considered.\n\n\n\n\n\naugmentprob(prob::RODEProblem, M; direction::Symbol=:both)\n\nCreate an augmented RODEProblem by aggregating the forward and backward Lagrangian descriptors to the given RODEProblem.\n\nMore precisely, with given f = prob.f, u0 = prob.u0, W = prob.noise, and tspan = prob.tspan, an augmented RODEProblem is created that solves the forward and backward RODE and the forward and backward Lagrangian descriptors simultaneously.\n\nThe (global) Lagrangian descriptors are based on the provided local descriptor M=M(du, u, p, t, W). The (forward/backward) Lagrangian descriptor is the time-integration of the local descriptor along the (forward/backward) trajectory.\n\nIf direction=:forward or direction=:backward are given, then only the forward or backard problem is constructed in the augmented system. The default is direction=:both, where both directions are considered.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"LagrangianDescriptors.LagrangianDescriptorProblem","category":"page"},{"location":"api/#LagrangianDescriptors.LagrangianDescriptorProblem","page":"API","title":"LagrangianDescriptors.LagrangianDescriptorProblem","text":"LagrangianDescriptorProblem\n\nDefines a Lagrangian descriptor problem associated with a SciML differential equations problem.\n\nConstructor\n\nLagrangianDescriptorProblem(prob, M, uu0; direction=:both)\n\nLagrangianDescriptorProblem can be constructed by passing a differential equation problem (currently only ODEProblem, but more problem types will be added), an infinitesimal Lagrangian descriptor with arguments compatible with the differential equation problem, an array of initial conditions, and, optionally, the direction of the flow.\n\nArguments\n\nprob: the differential equation problem (e.g. ODEProblem, SDEProblem, RODEProblem, etc.).\nM: infinitesimal Lagrangian descriptor (e.g. M=M(du, u, t, p) for an ODEProblem).\nuu0: collection of initial conditions.\ndirection: the direction of the flow, with default :both, but also accepting :forward and :backward.\n\nFields\n\nWith the given arguments, the constructor for LagrangianDescriptorProblem returns a type with the following arguments:\n\nensprob::T1: a suitable ensemble problem to be solved with the given collection of initial conditions uu0 for each solve, with a suitable prob_func to iterate through the collection and a suitable output_func to only collect the Lagrangian descriptors at the end of the time interval.\nuu0::T2: the given collection of initial conditions.\ndirection::T3: the given or the default direction of the flow.\n\nExample Problem\n\nHere we apply the Lagrangian descriptor method to a periodically-forced Duffing equation.\n\nusing OrdinaryDiffEq\nusing LinearAlgebra: norm\nusing LagrangianDescriptors\n\nfunction f!(du, u, p, t)\n    x, y = u\n    A, ω = p\n    du[1] = y\n    du[2] = x - x^3 + A * cos(ω * t)\nend\n\nu0 = [0.5, 2.2]\ntspan = (0.0, 13.0)\nA = 0.3; ω = π; p = (A, ω)\n\nprob = ODEProblem(f!, u0, tspan, p)\n\nM(du, u, p, t) = norm(du)\n\nuu0 = [[x, y] for y in range(-1.0, 1.0, length=301), x in range(-1.8, 1.8, length=301)]\n\nlagprob = LagrangianDescriptorProblem(prob, M, uu0)\n\nlagsol = solve(lagprob, Tsit5())\n\nplot(lagsol)\n\n\n\n\n\n","category":"type"},{"location":"api/#Solutions","page":"API","title":"Solutions","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LagrangianDescriptors.LagrangianDescriptorSolution","category":"page"},{"location":"api/#LagrangianDescriptors.LagrangianDescriptorSolution","page":"API","title":"LagrangianDescriptors.LagrangianDescriptorSolution","text":"struct LagrangianDescriptorSolution{T1, T2, T3}     enssol::T1     uu0::T2     direction::T3 end\n\nRepresentation of the solution to a LagrangianDescriptorProblem.\n\nFields\n\nenssol: the EnsembleSolution of the associated ensemble problem in LagrangianDescriptorProblem.\nuu0: the collection of initial conditions given in \n\nthe LagrangianDescriptorProblem.\n\ndirection: the direction given in the LagrangianDescriptorProblem.\n\n\n\n\n\n","category":"type"},{"location":"api/","page":"API","title":"API","text":"LagrangianDescriptors.solve","category":"page"},{"location":"api/#CommonSolve.solve","page":"API","title":"CommonSolve.solve","text":"solve(prob::LagrangianDescriptorProblem, alg, args...; kwargs...)\n\nSolve a LagrangianDescriptorProblem, which amounts to solving the associated EnsembleProblem in prob.ensprob and returning a LagrangianDescriptorSolution.\n\nYou should provide the necessary args and the desired kwargs for solving the associated ensemble problem for the underlying Differential Equation problem.\n\n\n\n\n\n","category":"function"},{"location":"api/#Post-processing","page":"API","title":"Post-processing","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"LagrangianDescriptors.lagrangian_descriptor","category":"page"},{"location":"api/#LagrangianDescriptors.lagrangian_descriptor","page":"API","title":"LagrangianDescriptors.lagrangian_descriptor","text":"lagrangian_descriptor(sol::ODESolution, M)\n\nComputes the Lagrangian descriptor of a single trajectory of an ODEProblem.\n\nIt takes the provided infinitesimal Lagrangian descriptor of the form M=M(du, u, p, t), along with the time interval given in sol.prob.tspan, to compute\n\nL = int_t_0^t_f M(du(t) u(t) p t) mathrmdt\n\nwhere t_0 and t_f are the initial and final times in sol.prob.tspan, u(t) = sol(t), p = sol.prob.p, and du(t) is computed from sol in a way dependent on whether sol.prob is in place or out of place.\n\nThe time integration is done via QuadGK.quadgk.\n\n\n\n\n\nlagrangian_descriptor(sol::RODESolution, M)\n\nComputes the Lagrangian descriptor of a single trajectory of a RODEProblem.\n\nIt takes the provided infinitesimal Lagrangian descriptor in the form M=M(du, u, p, t, W), along with the time interval given in sol.prob.tspan, to compute\n\nL = int_t_0^t_f M(du(t) u(t) p t W(t)) mathrmdt\n\nwhere t_0 and t_f are the initial and final times in sol.prob.tspan, u(t) = sol(t), p = sol.prob.p, W(t) = first(sol.W(t)), and du(t) is either du = sol.prob.f(sol(t), sol.prob.p, t, first(sol.W(t))) or given by sol.prob.f(du, sol(t), sol.prob.p, t, first(sol.W(t))), depending on whether sol.prob is in place or out of place.\n\nQuadGK.quadgk is an adaptive integration method and does not perform well on solutions of random or stochastic equations, so the integration, in these case, is performed via a simple trapezoidal rule on the mesh given by sol.t, which may be far com accurate depending on the mesh.\n\n\n\n\n\n","category":"function"},{"location":"postprocessing/#Alternative-via-post-processing","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"","category":"section"},{"location":"postprocessing/","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"Alternatively, instead of augmenting the system and computing the descriptor along with the solutions, we can just solve the original system as usual and then integrate the infinitesimal descriptor over the solution. This can be done for a single solution, backward and/or forward in time, or for an ensemble of solutions of the original system.","category":"page"},{"location":"postprocessing/#Drawbacks","page":"Alternative via post-processing","title":"Drawbacks","text":"","category":"section"},{"location":"postprocessing/","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"This is much simpler to implement, but it has some drawbacks:","category":"page"},{"location":"postprocessing/","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"First, we will need to save each trajectory in full, for later post-processing, instead of only L_mathrmfwd(t_f) and L_mathrmbwd(t_f). Hence, this is much more memory demanding. Keep in mind we need to solve for a lot of trajectories.\nIf we want the backward Lagrangian descriptors, we also need to set up and solve the system backward.\nSome solutions may have some spread out time steps saved by the solver. We either have to force it to save on a fine time mesh for an faster and accurate integration, or we use the interpolation present in the solution, which is usually much slower to compute.","category":"page"},{"location":"postprocessing/#Example","page":"Alternative via post-processing","title":"Example","text":"","category":"section"},{"location":"postprocessing/","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"Here we exemplify the idea by integrating a single solution of a scalar cubic equation using JuliaMath/QuadGK.jl.","category":"page"},{"location":"postprocessing/","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"It boils down to taking a solution sol of the ODEProblem and integrating the infinitesimal descriptor M with the apropriate arguments. In the case of a scalar ODE with an out-of-place right hand side f=f(u, p, t) and an infinitesimal descriptor M=M(u, p, t), this is simply","category":"page"},{"location":"postprocessing/","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"M(t) = M(sol(t), sol.prob.p, t)\nfirst(quadgk(M, minimum(tspan), maximum(tspan)))","category":"page"},{"location":"postprocessing/","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"For a more generic implementation for ODESolution types, in either in-place or out-of-place cases, and for either backward of forward descriptors, we define the function","category":"page"},{"location":"postprocessing/","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"function lagrangian_descriptor(sol::ODESolution, M)\n    t0, tf = extrema(sol.prob.tspan)\n    integrand = isinplace(sol.prob) ?\n        function (t, du = similar(sol.prob.u0))\n            sol.prob.f(du, sol(t), sol.prob.p, t)\n            M(du, sol(t), sol.prob.p, t)\n        end :\n        function (t)\n            du = sol.prob.f(sol(t), sol.prob.p, t)\n            M(du, sol(t), sol.prob.p, t)\n        end\n    return first(quadgk(integrand, t0, tf))\nend","category":"page"},{"location":"postprocessing/","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"With this definition, we compare the two different approaches, making sure they yield the same result, up to approximation errors:","category":"page"},{"location":"postprocessing/","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"using OrdinaryDiffEq, Test\nusing LagrangianDescriptors\nusing LagrangianDescriptors: augmentprob\nusing LinearAlgebra: norm\nusing QuadGK: quadgk\n\nf(u) = u - u^3\nf!(du, u, p, t) = (du .= f.(u))\n\nt0 = 0.0\ntf = 5.0\nn = 5\nu0 = 0.1 .+ 0.7rand(n)\n\ntspanfwd = (t0, tf)\nprobfwd = ODEProblem(f!, u0, tspanfwd)\n\ntspanbwd = (tf, t0)\nprobbwd = remake(probfwd, tspan = tspanbwd)\n\nsolfwd = solve(probfwd, Tsit5())\nsolbwd = solve(probbwd, Tsit5())\n\nM(du, u, p, t) = norm(du)\n\naugprob = augmentprob(probfwd, M)\naugsol = solve(augprob, Tsit5())\n\n@testset \"Augmented vs post-processing\" begin\n    @test augsol.u[end].lfwd ≈ lagrangian_descriptor(solfwd, M) rtol = 0.01\n    @test augsol.u[end].lbwd ≈ lagrangian_descriptor(solbwd, M) atol = 0.01\nend","category":"page"},{"location":"postprocessing/","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"Test Summary:                | Pass  Total  Time\nAugmented vs post-processing |    2      2  0.2s\nTest.DefaultTestSet(\"Augmented vs post-processing\", Any[], 2, false, false, true, 1.664213738359913e9, 1.664213738562828e9)","category":"page"},{"location":"postprocessing/#Benchmark","page":"Alternative via post-processing","title":"Benchmark","text":"","category":"section"},{"location":"postprocessing/","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"And here is a benchmark with the above setup, with a single solution of the augmented system versus post-processing:","category":"page"},{"location":"postprocessing/","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"using BenchmarkTools: @btime\n\n@info \"Create forward ODE problem:\"\n@btime ODEProblem($f!, $u0, $tspanfwd)\n\n@info \"Remake for backward ODE problem:\"\n@btime remake($probfwd, tspan = $tspanbwd)\n\n@info \"Solve forward ODE problem:\"\n@btime solve($probfwd, $(Tsit5()))\n\n@info \"Solve backward ODE problem:\"\n@btime solve($probbwd, $(Tsit5()))\n    \n@info \"Create augmented ODE problem:\"\n@btime augmentprob($probfwd, $M)\n    \n@info \"Solve Augmented ODE problem:\"\n@btime solve($augprob, $(Tsit5()))\n\n@info \"Postprocessing for forward Lagrangian descriptor:\"\n@btime $lagrangian_descriptor($solfwd, $M)\n\n@info \"Postprocessing for backward Lagrangian descriptor:\"\n@btime $lagrangian_descriptor($solbwd, $M)","category":"page"},{"location":"postprocessing/","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"[ Info: Create forward ODE problem:\n  4.327 μs (59 allocations: 2.34 KiB)\n[ Info: Remake for backward ODE problem:\n  2.084 ns (0 allocations: 0 bytes)\n[ Info: Solve forward ODE problem:\n  6.492 μs (146 allocations: 15.31 KiB)\n[ Info: Solve backward ODE problem:\n  6.508 μs (146 allocations: 15.31 KiB)\n[ Info: Create augmented ODE problem:\n  8.722 μs (130 allocations: 6.38 KiB)\n[ Info: Solve Augmented ODE problem:\n  22.916 μs (388 allocations: 38.05 KiB)\n[ Info: Postprocessing for forward Lagrangian descriptor:\n  97.750 μs (1488 allocations: 140.91 KiB)\n[ Info: Postprocessing for backward Lagrangian descriptor:\n  44.375 μs (677 allocations: 63.64 KiB)\n1.0964245933425085","category":"page"},{"location":"postprocessing/","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"We see that solving both forward and backward equations separately is a bit faster than solving the augmented system with both forward and backward evolutions together, but the latter also includes the computations of the Lagrangian descriptors. The number of allocations and memory are about the same.","category":"page"},{"location":"postprocessing/","page":"Alternative via post-processing","title":"Alternative via post-processing","text":"On the other hand, solving the forward and backward equations separately requires a post-processing step for each forward and backward evolutions to obtain the Lagrangian descriptors, and that takes quite a longer time and substantially more allocations and memory. And this was done for a single trajectory. Imagine for the ensemble of solutions, on top of the memory demand of saving the full solutions.","category":"page"},{"location":"tutorial_RODEs/#Random-Ordinary-Differential-Equations","page":"RODEs","title":"Random Ordinary Differential Equations","text":"","category":"section"},{"location":"tutorial_RODEs/","page":"RODEs","title":"RODEs","text":"We considere, now, some examples of applying the Lagragian descriptor method to equations of the type RODEProblem.","category":"page"},{"location":"tutorial_RODEs/#Random-Duffing-equation","page":"RODEs","title":"Random Duffing equation","text":"","category":"section"},{"location":"tutorial_RODEs/","page":"RODEs","title":"RODEs","text":"We consider, first, the random Duffing equation","category":"page"},{"location":"tutorial_RODEs/","page":"RODEs","title":"RODEs","text":"ddot x = x - x^3 + asin(W_t)","category":"page"},{"location":"tutorial_RODEs/","page":"RODEs","title":"RODEs","text":"where W_t_t is a standard Wiener process.","category":"page"},{"location":"tutorial_RODEs/","page":"RODEs","title":"RODEs","text":"With LagrangianDescriptors.jl, we i) start by setting up the equation as a RODEProblem; next, we ii) wrap that as a LagrangianDescriptorProblem; then we iii) solve it; and finally, we iv) plot the result with the built-in plot recipe.","category":"page"},{"location":"tutorial_RODEs/","page":"RODEs","title":"RODEs","text":"So we first load the relevant packages:","category":"page"},{"location":"tutorial_RODEs/","page":"RODEs","title":"RODEs","text":"using StochasticDiffEq, DiffEqNoiseProcess\nusing Plots\nusing LinearAlgebra: norm\nusing LagrangianDescriptors","category":"page"},{"location":"tutorial_RODEs/","page":"RODEs","title":"RODEs","text":"Next we set up the RODEProblem:","category":"page"},{"location":"tutorial_RODEs/","page":"RODEs","title":"RODEs","text":"function f!(du, u, p, t, W)\n    x, y = u\n    du[1] = y\n    du[2] = x - x^3 + p * sin(W)\nend\n\np = 0.025\nu0 = [0.5, 2.2]\ntspan = (0.0, 8.0)\nW = WienerProcess(0.0, 0.0)\n\nprob = RODEProblem(f!, u0, tspan, p, noise=W)","category":"page"},{"location":"tutorial_RODEs/","page":"RODEs","title":"RODEs","text":"With the RODE problem setup, we choose an infinitesimal Lagrangian descriptor, a collection of initial conditions on the phase space, which is the region to be \"painted\", and finally we build the LagrangianDescriptorProblem:","category":"page"},{"location":"tutorial_RODEs/","page":"RODEs","title":"RODEs","text":"M(du, u, p, t, W) = norm(du)\n\nuu0 = [[x, y] for y in range(-1.0, 1.0, length=301), x in range(-1.8, 1.8, length=301)]\n\nlagprob = LagrangianDescriptorProblem(prob, M, uu0)","category":"page"},{"location":"tutorial_RODEs/","page":"RODEs","title":"RODEs","text":"The Lagrangian descriptors are the time-integration of the infinitesimal descriptor along forward and backward solutions of the equation. They are integrated along with the solutions by \"solving\" the LagrangianDescriptorProblem, with an overload of the solve method from the SciML ecosystem:","category":"page"},{"location":"tutorial_RODEs/","page":"RODEs","title":"RODEs","text":"lagsol = solve(lagprob, RandomHeun(), dt=1/100)","category":"page"},{"location":"tutorial_RODEs/","page":"RODEs","title":"RODEs","text":"With the solution at hand, we plot the Lagrangian descriptors to visualize the dynamics of the system:","category":"page"},{"location":"tutorial_RODEs/","page":"RODEs","title":"RODEs","text":"plot(lagsol, title=\"Lagrangian descriptors for the random Duffing equation \\$\\\\ddot x = x - x^3 + a\\\\sin(W_t)\\$\\nwith \\$a=\\$$p\", titlefont=8, xlabel=\"\\$x\\$\", ylabel=\"\\$\\\\dot x\\$\")\n\nsavefig(\"img/duffing_random.png\")","category":"page"},{"location":"tutorial_RODEs/","page":"RODEs","title":"RODEs","text":"(Image: Duffing)","category":"page"},{"location":"#LagrangianDescriptors.jl-documentation","page":"Overview","title":"LagrangianDescriptors.jl documentation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Painting the phase portrait of deterministic and stochastic systems.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"(Image: Social preview)","category":"page"},{"location":"#About","page":"Overview","title":"About","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The dynamics of evolutionary systems can be quite intricate. The method of Lagrangian Descriptors helps to visualize the complicate behavior of such systems and make sense of it. In a recent article, Wiggins and and García-Garrido call it [a method for] painting the phase portrait (of a dynamical system) (see S. Wiggins and V. J. García-Garrido, Painting the Phase Portrait of a Dynamical System with the Computational Tool of Lagrangian Descriptors (AMS Notices, June/July 2022).","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The image above, for instance, shows the dynamics of a periodically-forced Duffing equation, with a particular combination of parameters and near time t=0.","category":"page"},{"location":"#Example","page":"Overview","title":"Example","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Here is the code that generates the background of the image above, displaying some dynamic features of the Duffing equation.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"using OrdinaryDiffEq, Plots\nusing LinearAlgebra: norm\nusing LagrangianDescriptors\n\nfunction f!(du, u, p, t)\n    x, y = u\n    A, ω = p\n    du[1] = y\n    du[2] = x - x^3 + A * sin(ω * t)\nend\n\nu0 = [0.5, 2.2]\ntspan = (0.0, 13.0)\nA = 5.0; ω = 2π; p = (A, ω);\nprob = ODEProblem(f!, u0, tspan, p)\n\nM(du, u, p, t) = norm(du)\nuu0 = [[x, y] for y in range(-1.5, -0.5, length=301), x in range(-0.4, 1.6, length=601)]\nlagprob = LagrangianDescriptorProblem(prob, M, uu0)\n\nlagsol = solve(lagprob, Tsit5())","category":"page"},{"location":"#Method","page":"Overview","title":"Method","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The method is akin to droping colored ink in a fluid flow, tracking the dye as it is transported by the flow, and revealing the pattern created after a certain period of time. The difference being that the color doesn't get diffused as in a real fluid, so the image doesn't get blurred and one gets a clearer picture.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"It is similar to drawing a phase portrait, which displays a collection of orbits, but in this method each orbit is painted according to its dynamic behavior, better revealing the overall picture.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"This \"coloring\" is obtained by integrating a local, or infinitesimal descriptor M=M(t u) along a solution u=u(t) of the system. One common choice for the infinitesimal descriptor is the velocity of the trajectory, so that, upon integration along the solution over a given period of time, the Lagrangian descriptor becomes the arc-length of that portion of the solution. Depending on whether the solution is at a fixed point, or belongs to a stable or unstable manifold, and so on, the arc-length would be closer for solutions with similar behavior, revealing the common patterns of the dynamics.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Thus, if u=u(t) is a solution over a time span (t_0 t_f), with t_f  t_0, then the forward Lagrangian descriptor is given by","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"L_mathrmfwd = int_t_0^t_f M(t u(t)) mathrmdt","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"If t_f  t_0, so that u=u(t) is a \"backward\" solution from t_0, then we obtain the backward Lagrangian descriptor","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"L_mathrmbwd = int_t_f^t_0 M(t u(t)) mathrmdt = - int_t_0^t_f M(t u(t)) mathrmdt","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Since the system might be non-autonomous, these Lagragians descriptors are referred as descriptors near t_0.","category":"page"},{"location":"#Approach","page":"Overview","title":"Approach","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Notice the computation of the Lagrangian descriptors only depend on a given solution and on the infinitesimal descriptor, so that they can be computed a posteriori. However, this is not the most efficient way of computing them. For a more efficient implementation, one writes the integrals for the Lagrangian descriptors as differential equations, i.e.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"fracmathrmdL_mathrmfwdmathrmdt = M(t u(t))","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"and similarly for the backward Lagrangian descriptor. Then, one solves the (partially) coupled system to obtain the integrated descriptor.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"More explicitly, when both forward and backward Lagrangians are desired, we may write a four-component system for solving both the backward and forward solutions and the backward and forward Lagrangians at the same time:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"begincases\n  displaystyle fracmathrmdumathrmdt = f(u t)  \n  displaystyle fracmathrmdvmathrmdt = -f(v 2t_0 - t)  \n  displaystyle fracmathrmdL_mathrmfwdmathrmdt = M(u t)  \n  displaystyle fracmathrmdL_mathrmbwdmathrmdt = M(v 2t_0 - t)\nendcases","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"with the set of initial conditions","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"u(t_0) = v(t_0) = u_0 quad L_mathrmfwd(t_0) = L_mathrmbwd(t_0) = 0","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"For a given time interval (t_0 t_f), with t_f  t_0, notice that u=u(t) solves the system forward, over the interval (t_0 t_f), while v=v(t) is defined over (t_0 t_f) but corresponds to solving the system backward, starting at t_0 and ending at 2t_0 - t_f = t_0 - (t_f - t_0), both with the same initial condition u_0, i.e. the augmented system computes the forward and backward parts of the same trajectory, over the same length of time, but in different directions.","category":"page"},{"location":"#Implementation","page":"Overview","title":"Implementation","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The API is simple, it amounts to i) building a LagrangianDescriptorProblem, ii) solving it with an overload of solve; and iii) plotting the solution with a plot recipe:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"lagprob = LagrangianDescriptorProblem(prob, M, uu0)\nlagsol = solve(lagprob, alg)\nplot(lagsol)","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"where prob is a given problem, such as an ODEProblem; M is the infinitesimal Lagrangian descriptor; uu0 is a collection of initial conditions; and alg is the algorithm chosen to solve prob, such as Tsit5().","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"More precisely, the implementation works as follows:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"One builds a differential equation problem prob of a type defined in SciMLBase.jl, from SciML/DifferentialEquations.jl, say an ODEProblem for mathrmdumathrmdt = f(u p t) (in-place or out-of-place). \nOne chooses an infinitesimal descriptor of the form M=M(du, u, p, t) (or other form suitable to the given problem type), with scalar values, that will be integrated along a solution u(t) = u(t u_0), to yield the forward Lagrangian descriptor L_mathrmfwd(u_0) and the backward Lagrangian descriptor L_mathrmbwd(u_0), for a given initial condition u_0.\nOne chooses a collection uu0 of initial conditions (e.g. a Vector, or a more general Array or any iterator, with the elements of the collection being suitable initial conditions for the given problem), representing a mesh in phase space or a portion of a sub-manifold of the phase space to be \"painted\" by the method.\nThen we pass them to lagprob = LagrangianDescriptorProblem(prob, M, uu0), to create the associated Lagrangian descriptor problem lagprob.\nLagrangianDescriptorProblem uses prob.f, prob.p, prob.u0, prob.tspan, and any prob.kwargs to create, via ComponentArrays, a new problem (e.g. a new ODEProblem) for the augmented system.\nThe augmented problem has, by default, four components, for solving the original equation forward and backward in time, and for solving the Lagrangian descriptors forward and backward in time. The way the augmented systems is constructed is via ComponentArrays.jl, so the augmented system is a ComponentVector, with components fwd, bwd, lfwd, and lbwd, respectively.\nOne may choose the keyword direction = :forward or direction = :backward to build the augmented system in only one direction, with the default being direction = :both.\nLagrangianDescriptorProblem then wraps an EnsembleProblem for the augmented system and with the given collection uu_0 of initial conditions to be used at each trajectory of the ensemble;\nSolve the LagrangianDescriptorProblem by invoking lagsol = solve(lagprob, alg, args..., kwargs...), with the appropriate algorithm and any other argument for the ensemble solve of the underlying ensemble problem lagprob.ensprob. \nsolve returns a LagrangianDescriptorSolution containing the associated collection of (forward and backward) Lagrangian descriptor values at the final time of each simulation (which is t_f for the forward components and corresponds to 2t_0 - t_f for the backward ones). This solution has the following fields:\nenssol: the EnsembleSolution of the associated ensemble problem, where enssol.u contains a vector with the component arays lfwd and lbwd (or only one of them, depending on the direction) for the Lagrangian descriptors at the final time of the simulation (i.e. t_f for the forward Lagrangian and 2t_0 - t_f for the backward);\nuu0: the given collection of initial conditions;\ndirection: the direction chosen, which defaults to :both, but can be also :forward or :backward.\nFinally, one can use plot to visualize either the forward, or the backward, or the sum (total), or even the difference, of the forward and backward Lagrangian descriptor, via a plot recipe for the LagrangianDescriptorSolution, i.e. by calling plot(lagsol) or plot(lagsol, direction), where direction is either :forward, :backward, :total or :difference.","category":"page"},{"location":"#Current-state","page":"Overview","title":"Current state","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"The package is still in an embrionary phase and currently accepts differential equations of the type ODEProblem and RODEProblem. Problems of the type SDEProblem will be implemented soon. Other problems will come eventually.","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"The plot recipe works for some types of collections of initial conditions (e.g. a AbstractVector{<:Number}, for scalar problems, and AbstractMatrix{<:AbstractVector{<:Number}} with the AbstractVector of length two, for two-dimensional problems). More general and flexible plot recipes will also be implemented.","category":"page"},{"location":"#Roadmap","page":"Overview","title":"Roadmap","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"What is currently missing:","category":"page"},{"location":"","page":"Overview","title":"Overview","text":"Support for other types of problems, such as SDEProblem, mixed differential-algebraic equations, etc.;\nA more flexible plot recipe;\nImprove the documentation with more examples;\nMaybe an adaptive method to refine the set uu0 of initial conditions!;\nI don't know whether/how the idea applies to delay type equations, but we should check that out.\nRegister the package.","category":"page"},{"location":"#References","page":"Overview","title":"References","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Painting the Phase Portrait of a Dynamical System with the Computational Tool of Lagrangian Descriptors\nLagrangian descriptors: A method for revealing phase space structures of general time dependent dynamical systems\nLagrangian Descriptors - Discovery and Quantification of Phase Space Structure and Transport\nFrequently Asked Questions about Lagrangian Descriptors","category":"page"},{"location":"#Developers","page":"Overview","title":"Developers","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"JuliaDynamics/LagrangianDescriptors.jl is currently being developed by Ricardo M. S. Rosa, but contributors are welcome.","category":"page"},{"location":"#Cite","page":"Overview","title":"Cite","text":"","category":"section"},{"location":"","page":"Overview","title":"Overview","text":"Just cite the github repo JuliaDynamics/LagrangianDescriptors.jl for now, while the package is not yet registered.","category":"page"},{"location":"tutorial_ODEs/#Ordinary-Differential-Equations","page":"ODEs","title":"Ordinary Differential Equations","text":"","category":"section"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"We considere, here, some examples of applying the Lagragian descriptor method to equations of the type ODEProblem.","category":"page"},{"location":"tutorial_ODEs/#Periodically-forced-Duffing-equation","page":"ODEs","title":"Periodically-forced Duffing equation","text":"","category":"section"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"We start with an application of the method of Lagrangian descriptors to the periodically-forced Duffing equation, as illustrated in Painting the Phase Portrait of a Dynamical System with the Computational Tool of Lagrangian Descriptors. The equation takes the form","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"ddot x = x - x^3 + Asin(omega t)","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"We write it as a system","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"begincases\n  dot x = y \n  dot y = x - x^3 + Asin(omega t)\nendcases","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"The idea is to set up this system as an ODEProblem from SciML/DifferentialEquations.jl, then wrap it as a LagrangianDescriptorProblem from LagrangianDescriptors.jl, which we can then solve as an ensemble problem and plot the result.","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"So we first load the relevant packages:","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"using OrdinaryDiffEq, Plots\nusing LinearAlgebra: norm\nusing LagrangianDescriptors","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"Next we set up the ODEProblem:","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"function f!(du, u, p, t)\n    x, y = u\n    A, ω = p\n    du[1] = y\n    du[2] = x - x^3 + A * sin(ω * t)\nend\n\nu0 = [0.5, 2.2]\ntspan = (0.0, 13.0)\nA = 0.3; ω = π; p = (A, ω)\n\nprob = ODEProblem(f!, u0, tspan, p)","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"With the ODE problem setup, we choose an infinitesimal Lagrangian descriptor, a collection of initial conditions on the phase space, which is the region to be \"painted\", and finally we build the LagrangianDescriptorProblem:","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"M(du, u, p, t) = norm(du)\n\nuu0 = [[x, y] for y in range(-1.0, 1.0, length=301), x in range(-1.8, 1.8, length=301)]\n\nlagprob = LagrangianDescriptorProblem(prob, M, uu0)","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"The Lagrangian descriptors are the time-integration of the infinitesimal descriptor along forward and backward solutions of the equation. They are integrated along with the solutions by \"solving\" the LagrangianDescriptorProblem, with an overload of the solve method from the SciML ecosystem:","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"lagsol = solve(lagprob, Tsit5())","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"With the solution at hand, we plot the Lagrangian descriptors to visualize the dynamics of the system:","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"plot(lagsol, title=\"Lagrangian descriptors for the forced Duffing equation \\$\\\\ddot x = x - x^3 + A\\\\sin(\\\\omega t)\\$\\nwith A=$A and ω=$ω\", titlefont=8, xlabel=\"\\$x\\$\", ylabel=\"\\$\\\\dot x\\$\")\n\nsavefig(\"img/duffing.png\")","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"(Image: Duffing)","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"We may zoom closer to the origin to find the following \"painting\":","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"uu0 = [[x, y] for y in range(-0.6, 0.3, length=601), x in range(-0.2, 0.4, length=401)]\nlagprob = LagrangianDescriptorProblem(prob, M, uu0)\n\nlagsol = solve(lagprob, Tsit5());\n\nplot(lagsol, title=\"Lagrangian descriptors for the forced Duffing equation \\$\\\\ddot x = x - x^3 + A\\\\sin(\\\\omega t)\\$\\nwith A=$A and ω=$ω\", titlefont=8, xlabel=\"\\$x\\$\", ylabel=\"\\$\\\\dot x\\$\")\n\nsavefig(\"img/duffing2.png\")","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"(Image: Duffing)","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"If we want to change parameters, we just remake the original ODEProblem (in the future I should add the option to remake the LagrangianDescriptorProblem itself.)","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"A = 2.0; ω = 2π; p = (A, ω);\nprob = remake(prob, p=p)\nuu0 = [[x, y] for y in range(-0.6, -0.1, length=501), x in range(-0.2, 0.3, length=401)]\nlagprob = LagrangianDescriptorProblem(prob, M, uu0)\n\nlagsol = solve(lagprob, Tsit5());\n\nplot(lagsol, title=\"Lagrangian descriptors for the forced Duffing equation \\$\\\\ddot x = x - x^3 + A\\\\sin(\\\\omega t)\\$\\nwith A=$A and ω=$ω\", titlefont=8, xlabel=\"\\$x\\$\", ylabel=\"\\$\\\\dot x\\$\")\n\nsavefig(\"img/duffing3.png\")","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"(Image: Duffing)","category":"page"},{"location":"tutorial_ODEs/#Autonomous-Duffing-equation","page":"ODEs","title":"Autonomous Duffing equation","text":"","category":"section"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"For visualizing the autonomous case, we may rewrite the system or, since we already have the non-autonomous case implemented, we just set the amplitude of the forcing term to zero:","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"A = 0.0; ω = 2π; p = (A, ω);\nprob = remake(prob, p=p)\nuu0 = [[x, y] for y in range(-1.0, 1.0, length=301), x in range(-1.8, 1.8, length=301)]\nlagprob = LagrangianDescriptorProblem(prob, M, uu0)\n\nlagsol = solve(lagprob, Tsit5());\n\nplot(lagsol, title=\"Lagrangian descriptors for the forced Duffing equation \\$\\\\ddot x = x - x^3 + A\\\\sin(\\\\omega t)\\$\\nwith A=$A and ω=$ω\", titlefont=8, xlabel=\"\\$x\\$\", ylabel=\"\\$\\\\dot x\\$\")\n\nsavefig(\"img/duffing4.png\")","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"(Image: Duffing)","category":"page"},{"location":"tutorial_ODEs/#A-scalar-cubic-equation","page":"ODEs","title":"A scalar cubic equation","text":"","category":"section"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"Although one-dimensional problems are easier to understand, the method also works for such problems. Here we experiment with the scalar cubic equation","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"   fracmathrmdxmathrmdt = x - x^3","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"This equation has two stationary solutions, associated with the fixed points x=0 and x=1.","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"We setup the ODEProblem:","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"f(u, p, t) = u - u^3\n\nu0 = 0.5\ntspan = (0.0, 1.0)\nprob = ODEProblem(f, u0, tspan, p)","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"Build the LagrangianDescriptorProblem:","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"M(du, u, p, t) = norm(du)\nuu0 = range(-1.0, 1.0, length = 201)\nlagprob = LagrangianDescriptorProblem(prob, M, uu0)","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"Solve it:","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"lagsol = solve(lagprob, Tsit5())","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"and plot it:","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"plot(\n    uu0,\n    lagsol(:forward),\n    label = \"forward\",\n    title = \"Lagrangian descriptors for a cubic equation\",\n    titlefont = 10,\n)\nplot!(uu0, lagsol(:backward), label = \"backward\")\nplot!(uu0, lagsol(), label = \"total\")\nplot!(uu0, lagsol(:difference), label = \"difference\")\n\nsavefig(\"img/cubic.png\")","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"In any of the Lagrangian descriptors (forward, backward, total, and difference) we distinguish the two fixed points.","category":"page"},{"location":"tutorial_ODEs/","page":"ODEs","title":"ODEs","text":"(Image: Cubic)","category":"page"}]
}
